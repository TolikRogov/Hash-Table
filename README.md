# Hash Table

---

## Оглавление

- [Введение](#введение)
- [Цель и задачи](#цель-и-задачи)
- [Методика измерений](#методика-измерений)
- [Выбор хэш-функции](#выбор-хэш-функции)
- [Анализ результатов](#анализ-результатов)
- [Вывод](#вывод)

---

## Введение

Хэш-таблица (**_Hash Table_**) — это структура данных, позволяющая хранить элементы в представлении ключ-значения. Хэш-таблица использует хэш-функцию для вычисления числа (**_хэш_**/**_hash_**) по ключу, которое указывает в какой слот (**_bucket_**) попадет ключ со своими значениями.

Бывают случаи, когда хэш-функция выдает один и тот же хэш для разных ключей - это называется **_коллизией_**. В результате коллизии в одном слоте (bucket-е) находится множество различных элементов, что затрудняет поиск правильного значения по ключу. Как можно разрешить проблему коллизии?

1. **Метод списков** (цепочек) - используется в работе

Каждый слот массива - указатель на связный список пар ключ-значения, для которых хеш-функция выдала один результат. Коллизии приводят к тому, что появляются списки длиной более одного элемента. Чтобы избежать коллизий в данной работе используется линейный поиск элементов внутри списка (bucket-а).

<figure style="text-align: center;">
    <img src="img/separate_chaining.png" alt="Метод списков" width="300">
    <figcaption>Метод списков</figcaption>
</figure>

2. **Открытая адресация**

Элементы хэш-таблицы хранятся в общем массиве. Если происходит коллизия, то ищется свободная ячейка по определенной схеме (**_метод пробирования_**/**_probing_**) в зависимости от реализации: линейное, квадратичное пробирование или двойное хэширование.

<figure style="text-align: center;">
    <img src="img/separate_chaining.png" alt="Открытая адресация" width="300">
    <figcaption>Открытая адресация</figcaption>
</figure>

Одним из ключевых параметров оценки эффективности хэш-таблицы является фактор/коэффициент загрузки (**_load factor_**):

$$Load \space factor = \frac{Количество \space объектов \space в \space таблице \space (N)}{Размер \space таблицы \space (n)}$$

> [!NOTE]
> Для получения корректного результата при работе хэш-таблицы со строковыми данными следует помнить, что N - количество **уникальных** входных слов, n - общий размер массива (в случае метода списков - количество самих списков, bucket-ов)

> [!IMPORTANT]
> На практике для достижения наибольшей производительности и минимизации коллизий в хэш-таблице оптимальным диапазоном значений для фактора загрузки является:
>
> 1. Для открытой адресации: `Load factor < 1` (_"В любой момент размер таблицы должен быть больше или равен общему количеству ключей"_ - [Geeksforgeeks.org](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)).
> 2. Для метода списков: `1 < Load factor < 3` (источник - [Wikipedia/HashTable](https://en.wikipedia.org/wiki/Hash_table))

> [!WARNING]
> В учебных целях фактор загрузки в данной работе был **увеличен** специально для получения частых ситуаций коллизий, которые замедляют поиск. Это позволило лучше отслеживать скорость выполнения алгоритма поиска элементов в хэш-таблице на каждом этапе его оптимизации.

В качестве входных данных для хэш-таблицы было выбрано произведение _J.R.R Tolkien "The Lord of the Ring 1 - The Fellowship of the Ring"_ в оригинале. После обработки во входном файле оказалось `531307` слов, из которых `19030` являются уникальными. Изначальный размер хэш-таблицы - `1024`, обоснование подобного выбора размера будет приведено _далее_ в работе. $Load \space factor \approx 19$.

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Цель и задачи

**_Цель_** - провести оптимизацию алгоритма поиска элементов в собственной реализации хэш-таблицы с использованием различных ассемблерных оптимизаций и инструментов для оценки производительности программы.

**_Задачи_**:

1. Выбрать хэш-функцию для таблицы
2. Написать реализацию хэш-таблицы
3. Выбрать инструмент оценки производительности программы
4. Провести оптимизации наиболее _горячих_ функций поиска
5. Проанализировать результаты оптимизаций

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Методика измерений

1.  **Характеристики аппаратуры**

    - Операционная система: Linux 6.11.0-21-generic (x86_64)
    - Процессор: 12th Gen Intel(R) Core(TM) i5-12600KF; 10 cores; 16 treads
    - Компилятор:

> [!TIP]
> Для проверки корректности работы соответствующих оптимизаций будем сравнивать результаты вычислений множества Мандельброта с помощью графической библиотеки. Будем следить за изменениями полученного изображения, чтобы исправить оптимизации, нарушившие ход выполнения программы.

> [!IMPORTANT]
> Все последующие измерения времени будем проводить без использовани графической библиотеки, рассчитывая каждую из точек по 300 раз для увеличения среднего времени выполнения программы.

---

## Выбор хэш-функции

---

## Базовая версия

1. **С оптимизацией `-O3`:**
   | № | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
   | :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
   | t, c | 18,80 | 18,74 | 18,80 | 18,80 | 18,72 | 18,81 | 18,75 | 18,80 | 18,82 | 18,73 |

   **Статистика**

   - Среднее время: `18,77 ± 0,33` с (`1,8` %)
   - FPS: `16,86 ± 0,16` (`0,96` %)

<figure style="text-align: center;">
    <img src="data/imgs/mandelbrot.png" alt="Мандельброт v1.1" width="300">
    <figcaption>Мандельброт v1.1</figcaption>
</figure>

2. **Без оптимизации:**
   | № | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
   | :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
   | t, c | 39,79 | 39,78 | 39,88 | 39,74 | 40,02 | 39,87 | 39,58 | 39,58 | 39,59 | 39,64 |

   **Статистика**

   - Среднее время: `39,75 ± 0,71` с (`1,8` %)
   - FPS: `8,46 ± 0,02` (`0,27` %)

---

## Версия на массивах

1. **С оптимизацией `-O3`:**
   | № | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
   | :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
   | t, c | 10,04 | 10,48 | 10,14 | 10,49 | 10,15 | 10,53 | 10,05 | 10,05 | 10,51 | 10,14 |

   **Статистика**

   - Среднее время: `10,26 ± 0,22` с (`2,2` %)
   - FPS: `29,12 ± 0,94` (`3,2` %)

2. **Без оптимизации:**
   | № | 1 | 2 | 3 | 4 | 5 |
   | :--: | :---: | :---: | :---: | :---: | :---: |
   | t, c | 255,34 | 255,16 | 255,00 | 255,83 | 255,65 |

   **Статистика**

   - Среднее время: `254,99 ± 4,52` с (`1,8` %)
   - FPS: `1,77 ± 0,01` (`0,56` %)

---

## Intrinsics версия

1. **С оптимизацией `-O3`:**
   | № | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
   | :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
   | t, c | 6,23 | 6,15 | 6,18 | 6,18 | 6,23 | 6,17 | 6,20 | 6,19 | 6,19 | 6,18 |

   **Статистика**

   - Среднее время: `6,19 ± 0,11` с (`1,8` %)
   - FPS: `47,35 ± 4,23` (`8,9` %)

<figure style="text-align: center;">
    <img src="data/imgs/Mandelbrot_v3_1.png" alt="Мандельброт v3.1" width="300">
    <figcaption>Мандельброт v3.1</figcaption>
</figure>

2. **Без оптимизации:**
   | № | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
   | :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
   | t, c | 32,12 | 31,83 | 32,17 | 32,22 | 32,16 | 32,16 | 31,94 | 32,18 | 32,11 | 31,88 |

   **Статистика**

   - Среднее время: `32,08 ± 0,57` с (`1,8` %)
   - FPS: `10,17 ± 0,01` (`0,1` %)

---

## Анализ результатов

> [!NOTE]
> Наибольшее ускорение достигнуто при использовании Intrinsics: время выполнения сократилось в ~3 раза по сравнению с базовой версией.

> [!NOTE]
> Версия на массивах без оптимизации оказалась наименее эффективной.

<figure style="text-align: center;">
    <img src="data/imgs/results.png" alt="Results" width="300">
</figure>

---

## Вывод

В ходе работы была реализована модель множества Мандельброта с применением различных оптимизаций. Наилучший результат показала Intrinsics версия с оптимизацией `-O3`, что подтверждает эффективность использования SIMD-инструкций для ускорения вычислений. Итоговый прирост производительности составил примерно 3 раза, что соответствует ожиданиям для однопоточных оптимизаций.

$$
$$
